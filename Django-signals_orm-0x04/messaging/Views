# messaging/Views - Task 2 Implementation
# Use Signals for Deleting User-Related Data

from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.contrib import messages
from django.views.decorators.http import require_http_methods
from django.http import JsonResponse
from django.db import transaction


@login_required
@require_http_methods(["POST", "DELETE"])
def delete_user(request):
    """
    Task 2: View that allows a user to delete their account.
    
    This view implements user account deletion with automatic cleanup
    of related data through Django signals (post_delete signal).
    
    The post_delete signal will automatically:
    - Delete all messages sent by the user
    - Delete all messages received by the user  
    - Delete all notifications for the user
    - Delete all message histories edited by the user
    """
    if request.method == "POST":
        try:
            with transaction.atomic():
                user = request.user
                user_id = user.id
                username = user.username
                
                # Log the deletion attempt
                print(f"Attempting to delete user: {username} (ID: {user_id})")
                
                # Delete the user - this will trigger the post_delete signal
                # which handles cleanup of all related data
                user.delete()
                
                # If we reach here, deletion was successful
                return JsonResponse({
                    'success': True,
                    'message': f'User account {username} has been successfully deleted.',
                    'deleted_user_id': str(user_id)
                })
                
        except Exception as e:
            return JsonResponse({
                'success': False,
                'error': f'Failed to delete user account: {str(e)}'
            }, status=500)
    
    elif request.method == "DELETE":
        # Handle DELETE method for API-style requests
        try:
            user = request.user
            user.delete()
            return JsonResponse({'success': True, 'message': 'Account deleted'})
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)}, status=500)


@login_required
def delete_user_confirmation(request):
    """
    Display confirmation page before user deletion.
    """
    if request.method == "GET":
        return render(request, 'messaging/delete_user_confirmation.html', {
            'user': request.user
        })


@login_required
def user_data_summary(request):
    """
    Show user what data will be deleted when they delete their account.
    This helps users understand the scope of the deletion.
    """
    from .models import Message, Notification, MessageHistory
    
    user = request.user
    
    # Count related data that will be deleted
    sent_messages_count = Message.objects.filter(sender=user).count()
    received_messages_count = Message.objects.filter(receiver=user).count()
    notifications_count = Notification.objects.filter(user=user).count()
    edit_history_count = MessageHistory.objects.filter(edited_by=user).count()
    
    context = {
        'user': user,
        'data_summary': {
            'sent_messages': sent_messages_count,
            'received_messages': received_messages_count,
            'notifications': notifications_count,
            'edit_history': edit_history_count,
            'total_items': sent_messages_count + received_messages_count + notifications_count + edit_history_count
        }
    }
    
    return render(request, 'messaging/user_data_summary.html', context)


# Additional utility view for testing signal functionality
@login_required
def test_signal_cleanup(request):
    """
    Development/testing view to verify signal-based cleanup works correctly.
    This view should only be available in development environments.
    """
    from django.conf import settings
    
    if not settings.DEBUG:
        return JsonResponse({'error': 'This endpoint is only available in debug mode'}, status=403)
    
    from .models import Message, Notification, MessageHistory
    
    user = request.user
    
    # Get counts before deletion
    before_counts = {
        'messages_sent': Message.objects.filter(sender=user).count(),
        'messages_received': Message.objects.filter(receiver=user).count(),
        'notifications': Notification.objects.filter(user=user).count(),
        'edit_history': MessageHistory.objects.filter(edited_by=user).count(),
    }
    
    return JsonResponse({
        'user_id': user.id,
        'username': user.username,
        'data_before_deletion': before_counts,
        'message': 'Use the delete_user endpoint to test signal-based cleanup'
    })


"""
Signal Implementation for Task 2 (would be in signals.py):

from django.db.models.signals import post_delete
from django.dispatch import receiver
from django.contrib.auth.models import User

@receiver(post_delete, sender=User)
def cleanup_user_data(sender, instance, **kwargs):
    '''
    Signal that automatically cleans up related data when a user deletes their account.
    
    This signal ensures that foreign key constraints are respected during 
    the deletion process by using CASCADE or custom signal logic.
    '''
    from .models import Message, Notification, MessageHistory
    
    # Log the cleanup operation
    print(f"Cleaning up data for deleted user: {instance.username} (ID: {instance.id})")
    
    try:
        # Delete all messages sent by the user
        sent_messages_deleted = Message.objects.filter(sender=instance).delete()
        
        # Delete all messages received by the user
        received_messages_deleted = Message.objects.filter(receiver=instance).delete()
        
        # Delete all notifications for the user
        notifications_deleted = Notification.objects.filter(user=instance).delete()
        
        # Delete all message edit histories by the user
        edit_history_deleted = MessageHistory.objects.filter(edited_by=instance).delete()
        
        print(f"Cleanup completed:")
        print(f"- Sent messages: {sent_messages_deleted}")
        print(f"- Received messages: {received_messages_deleted}")
        print(f"- Notifications: {notifications_deleted}")
        print(f"- Edit history: {edit_history_deleted}")
        
    except Exception as e:
        print(f"Error during user data cleanup: {str(e)}")
        # In production, you might want to log this to a proper logging system
        # and potentially raise the exception to prevent user deletion if cleanup fails
"""